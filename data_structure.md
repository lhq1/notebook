数组

内存中连续的多个元素，第一个下标为0

优点：

可通过索引直接访问，查询方便

缺点：

数组大小确定后无法扩容

只能储存同类数据

添加删除操作慢（影响后方所有数据）

***

栈

后进先出，先进入的数据在栈底，只允许对栈顶进行操作

***

队列

先进先出，从一边加入数据，从另一边取出数据

***

链表

在内存中不一定连续，由指针确定储存的位置

优点：

不需要初始化

添加删除方便，直接修改指针即可

缺点：

大量指针占用大量空间

查找元素需要遍历，非常浪费时间

***

树

由结点和边组成的，不含任何环的图

> 二叉树
>
> > 完美二叉树
> >
> > 除叶子结点之外每一个结点都有两个孩子，除最后一层外每一层都被填满
>
> >完全二叉树
> >
> >除最后一层外每一层都被填满，所有结点保持向左对齐
>
> >除叶子结点外每个结点都有两个孩子
>
> 遍历
>
> 先序遍历：根-左-右
>
> ![这里写图片描述](https://img-blog.csdn.net/20150711163642225)
>
> 中序遍历：左-根-右
>
> ![这里写图片描述](https://img-blog.csdn.net/20150711163947878)
>
> 后序遍历：左-右-根
>
> ![这里写图片描述](https://img-blog.csdn.net/20150711164230063)
>
> 层次遍历：按层遍历
>
> ![这里写图片描述](https://img-blog.csdn.net/20150711164443595)

>二叉查找树
>
>任意树结点左结点>根>右结点，没有键值相等的结点

>AVL树
>
>带有平衡条件的二叉查找树，平衡条件必须满足所有节点的左右子树高度差不超过1。不管我们是执行插入还是删除操作,只要不满足上面的条件,就要通过旋转来保持平衡,而旋转是非常耗时的。
>
>适用于插入删除较少，查找多的情况

> 红黑树（std中map和set的实现方法）
>
> 结点是红色或者黑色
>
> 根结点，叶子结点：黑
>
> 每个红色结点的两个子结点都是黑色（不存在两个连续的红结点）
>
> 任一结点到其每个叶结点有相同的黑色结点数
>
> 查询功能不如AVL树，比AVL树多一层不平衡，需多一次比较。但插入和删除最多只需要三次旋转处理不平衡的问题

> B树
>
> 定义任意非叶子结点最多只有`M`个儿子；且M>2，根结点的儿子数为[2, M]
>
> 除根结点以外的非叶子结点的儿子数为[M/2, M]
>  每个结点存放至少`M/2-1`（取上整）和至多`M-1`个关键字；（至少2个关键字）
> 非叶子结点的关键字个数=指向儿子的指针个数-1
> 非叶子结点的关键字：`K[1], K[2], …, K[M-1]；且k[i]< K[i+1]`
>
> 非叶子结点的指针：P[1], P[2], …, P[M]`，其中`P[1]指关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于`(K[i-1], K[i])的子树
> 所有叶子结点位于同一层
>
> ![img](https://upload-images.jianshu.io/upload_images/4630295-be637e44f62bd8dd.png?imageMogr2/auto-orient/strip|imageView2/2/w/622/format/webp)

> B+的特性：
> 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的
> 不可能在非叶子结点命中
> 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层
> 更适合文件索引系统
> 原因： 增删文件（节点）时，效率更高，因为B+树的子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率
>
> ![img](https://upload-images.jianshu.io/upload_images/4630295-486680e4ce7ef709.png?imageMogr2/auto-orient/strip|imageView2/2/w/582/format/webp)

***

散列表

散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。

***

堆

堆中的结点的值总是不大于或者不小于其父结点

堆是一颗完全二叉树

根结点最大/小：最大/小堆

***

图